<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Kingdom of Li</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600&display=swap" rel="stylesheet">
    <style>
      :root {
        --gold: #f3c969;
        --blue: #3a7bd5;
        --pink: #f3a0c4;
        --ink: #1a1a1a;
        --glass: rgba(255, 255, 255, 0.75);
      }

      * {
        box-sizing: border-box;
      }

      html, body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: "Cormorant Garamond", "Georgia", "Times New Roman", serif;
        color: var(--ink);
        display: grid;
        place-items: center;
        text-align: center;
        padding: 24px;
        min-height: 100svh;
        overflow: hidden;
      }

      @supports (height: 100svh) {
        body {
          height: 100svh;
        }
      }

      body.kingdom {
        background: radial-gradient(circle at top, var(--gold), transparent 55%),
          linear-gradient(90deg, #0a1736 0%, #0a1736 45%, #b40e1a 100%);
        background-size: 200% 200%;
        animation: drift 18s ease-in-out infinite;
        overflow: hidden;
        position: fixed;
        width: 100%;
      }

      body.vb {
        background: radial-gradient(circle at top, rgba(255, 255, 255, 0.65), transparent 55%),
          linear-gradient(135deg, #f9c5de 0%, #f7a7cc 45%, #f3a0c4 100%),
          repeating-linear-gradient(115deg, rgba(255, 255, 255, 0.35) 0px, rgba(255, 255, 255, 0.35) 8px, transparent 8px, transparent 22px);
      }

      body.vb.playing #completedPanel {
        display: none !important;
      }

      body.vb.playing #countdownPanel,
      body.vb.playing #logoPanel {
        display: none !important;
      }

      @keyframes drift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }

      main {
        width: min(560px, 92vw);
        background: var(--glass);
        border-radius: 20px;
        padding: 28px 24px 30px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(8px);
        min-height: 320px;
        transition: transform 250ms ease;
      }

      #kingdomNode:focus-within {
        transform: translateY(-10px);
      }

      h1 {
        margin: 0 0 18px;
        font-size: clamp(26px, 5vw, 36px);
        letter-spacing: 0.5px;
      }

      .status {
        color: rgba(0, 0, 0, 0.55);
        font-size: 17px;
        margin: 10px 0 18px;
      }

      .status.error {
        color: #b40e1a;
      }

      .credentials {
        display: grid;
        gap: 8px;
        margin: 14px 0 22px;
        transition: opacity 300ms ease, transform 300ms ease;
      }

      .credentials input {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: rgba(255, 255, 255, 0.7);
        font-size: 18px;
      }

      .enter {
        border: none;
        background: var(--blue);
        color: white;
        padding: 14px 26px;
        border-radius: 999px;
        cursor: pointer;
        transition: transform 150ms ease, box-shadow 150ms ease;
        width: 100%;
        opacity: 0;
        pointer-events: none;
        font-size: 18px;
      }

      .enter.is-active {
        opacity: 1;
        pointer-events: auto;
        transition: opacity 300ms ease;
      }

      .action-area {
        min-height: 220px;
        display: grid;
        align-content: start;
      }

      .action-area.loading .credentials,
      .action-area.loading .enter {
        display: none;
      }


      .enter:active {
        transform: scale(0.98);
      }

      .enter:focus-visible {
        outline: 2px solid rgba(0, 0, 0, 0.6);
        outline-offset: 2px;
      }

      .loader {
        display: grid;
        justify-items: center;
        gap: 10px;
        margin-top: 12px;
        min-height: 180px;
      }

      .spinner {
        width: 26px;
        height: 26px;
        border-radius: 50%;
        border: 3px solid rgba(58, 123, 213, 0.2);
        border-top-color: rgba(58, 123, 213, 0.9);
        animation: spin 0.9s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .loader-text {
        font-size: 17px;
        color: rgba(0, 0, 0, 0.6);
        min-height: 120px;
        text-align: center;
      }

      .loader-text .line {
        margin: 4px 0;
      }

      .fade-in {
        animation: fadeIn 0.6s ease;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .loader-graphic {
        width: 180px;
        height: 6px;
        border-radius: 999px;
        background: rgba(58, 123, 213, 0.2);
        overflow: hidden;
        display: none;
      }

      .loader-graphic span {
        display: block;
        height: 100%;
        width: 35%;
        border-radius: 999px;
        background: rgba(58, 123, 213, 0.8);
        animation: glide 1.4s ease-in-out infinite;
      }

      @keyframes glide {
        0% { transform: translateX(-40%); }
        50% { transform: translateX(180%); }
        100% { transform: translateX(-40%); }
      }

      .accent {
        color: #f07bb0;
        font-weight: 600;
      }

      .hidden {
        display: none !important;
      }

      .snapshot {
        background: rgba(255, 255, 255, 0.6);
        border-radius: 16px;
        padding: 18px 16px;
        min-height: 110px;
        font-size: 17px;
      }

      .controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-top: 16px;
      }

      .controls button {
        border: none;
        background: var(--blue);
        color: white;
        padding: 8px 16px;
        border-radius: 999px;
        font-size: 15px;
        cursor: pointer;
      }

      .controls span {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.6);
      }

      #vbNode {
        width: 100%;
        height: 100%;
        padding: 0;
        background: transparent;
        box-shadow: none;
        border-radius: 0;
        position: fixed;
        inset: 0;
        overflow: hidden;
      }

      .thought {
        position: absolute;
        max-width: min(70vw, 420px);
        padding: 16px 18px;
        background: rgba(255, 255, 255, 0.68);
        border-radius: 16px;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
        font-size: 19px;
        color: rgba(0, 0, 0, 0.7);
        text-shadow: 0 4px 14px rgba(0, 0, 0, 0.06);
        cursor: pointer;
      }

      .thought img {
        max-width: 100%;
        height: auto;
        display: block;
        border-radius: 12px;
      }

      .exit-node {
        border: none;
        background: rgba(255, 255, 255, 0.85);
        color: rgba(0, 0, 0, 0.7);
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.12);
      }

      .completed-node {
        border: none;
        background: rgba(255, 255, 255, 0.85);
        color: rgba(0, 0, 0, 0.7);
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.12);
      }

      .vb-subheader {
        position: fixed;
        top: 70px;
        left: 12px;
        right: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 14px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.85);
        color: rgba(0, 0, 0, 0.7);
        font-size: 14px;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
        z-index: 2;
        display: none;
      }

      .vb-subheader span {
        font-weight: 600;
      }

      .completed-panel {
        position: fixed;
        top: 20px;
        left: 12px;
        right: 12px;
        max-height: 45vh;
        overflow: auto;
        padding: 14px 16px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.18);
      }

      .stop-playback {
        position: fixed;
        top: 18px;
        right: 16px;
        border: none;
        background: rgba(58, 123, 213, 0.9);
        color: white;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
        z-index: 4;
      }

      .roses-panel {
        position: fixed;
        top: 12px;
        bottom: 12px;
        left: 12px;
        right: 12px;
        display: grid;
        grid-template-rows: 0 1fr auto;
        gap: 14px;
        padding: 18px;
        background: linear-gradient(180deg, rgba(255, 232, 244, 0.95) 0%, rgba(255, 248, 252, 0.98) 100%);
        border-radius: 22px;
        box-shadow: 0 18px 32px rgba(180, 14, 26, 0.12), 0 8px 18px rgba(0, 0, 0, 0.12);
        z-index: 3;
      }

      .roses-header {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 10px;
        height: 0;
        overflow: visible;
      }

      .roses-close {
        display: none;
      }

      .roses-title {
        font-size: 13px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
        flex: 1;
      }

      .roses-body {
        display: grid;
        grid-template-rows: 1fr auto;
        align-items: center;
        gap: 12px;
        overflow: hidden;
        min-height: 0;
      }

      .roses-polaroid {
        display: inline-block;
        padding: 8px;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 16px;
        border: 1px solid rgba(243, 160, 196, 0.35);
        box-shadow: 0 0 22px rgba(243, 160, 196, 0.35), 0 10px 20px rgba(0, 0, 0, 0.12);
        justify-self: center;
        align-self: center;
      }

      .roses-image {
        width: auto;
        height: auto;
        max-height: 100%;
        max-width: 100%;
        object-fit: contain;
        border-radius: 12px;
        background: transparent;
        justify-self: center;
        align-self: center;
        display: block;
      }

      .roses-note {
        font-size: 14px;
        line-height: 1.45;
        color: rgba(120, 24, 64, 0.78);
        background: rgba(255, 233, 243, 0.85);
        border-radius: 16px;
        padding: 14px 16px;
        border: 1px solid rgba(243, 160, 196, 0.35);
        max-width: min(560px, 92%);
        text-align: center;
        justify-self: center;
        align-self: center;
      }

      .roses-nav {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 18px;
        margin-top: auto;
      }

      .roses-counter {
        font-size: 12px;
        color: rgba(120, 24, 64, 0.55);
        letter-spacing: 1px;
      }

      .roses-prev,
      .roses-next,
      .roses-back {
        border: none;
        background: rgba(255, 233, 243, 0.8);
        color: rgba(120, 24, 64, 0.7);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 22px;
        cursor: pointer;
        box-shadow: 0 8px 16px rgba(243, 160, 196, 0.35);
      }

      .roses-back {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.55);
      }

      .roses-back-top {
        position: absolute;
        top: 6px;
        left: 10px;
        border: none;
        background: transparent;
        color: rgba(0, 0, 0, 0.55);
        padding: 2px 4px;
        font-size: 18px;
        cursor: pointer;
      }

      .completed-panel h2 {
        margin: 0 0 10px;
        font-size: 18px;
      }

      .completed-panel .panel-divider {
        height: 1px;
        background: rgba(0, 0, 0, 0.12);
        margin: 6px 0 12px;
      }

      .completed-panel ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 10px;
      }

      .completed-panel .countdown {
        margin-top: 14px;
        font-size: 13px;
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
      }

      .countdown-panel {
        position: fixed;
        left: 12px;
        right: 12px;
        padding: 12px 14px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);
        font-size: 13px;
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
      }

      .countdown-panel .countdown-time {
        margin-top: 6px;
        font-size: 20px;
        font-weight: 600;
        color: #b40e1a;
        letter-spacing: 1px;
      }

      .logo-panel {
        position: fixed;
        top: 50%;
        bottom: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 8px;
        padding: 0;
      }

      .logo-panel img {
        max-width: 220px;
        width: 60%;
        height: auto;
        opacity: 1;
        filter: drop-shadow(0 12px 24px rgba(243, 160, 196, 0.35));
      }

      .leave-button {
        border: none;
        background: rgba(255, 233, 243, 0.85);
        color: rgba(120, 24, 64, 0.7);
        padding: 8px 18px;
        border-radius: 999px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 10px 20px rgba(243, 160, 196, 0.25);
      }

      .completed-panel li {
        font-size: 14px;
        color: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .completed-panel small {
        font-size: 12px;
        color: rgba(0, 0, 0, 0.55);
      }

      .episode-pending {
        color: rgba(0, 0, 0, 0.4);
      }

      .episode-actions {
        margin-top: 8px;
        display: flex;
        gap: 8px;
      }

      .episode-actions button {
        border: none;
        background: rgba(58, 123, 213, 0.9);
        color: white;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        cursor: pointer;
      }

      body, main {
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
    </style>
  </head>
  <body class="kingdom">
    <main id="kingdomNode">
      <div>
        <h1>Kingdom</h1>
        <p id="deviceText" class="status"></p>
      </div>
      <p id="statusText" class="status"></p>

      <div id="actionArea" class="action-area">
        <div class="credentials">
          <input id="username" type="text" placeholder="Username" autocomplete="off" inputmode="text">
          <input id="password" type="password" placeholder="Password" autocomplete="off" inputmode="text">
        </div>

        <button id="enterButton" class="enter" type="button">Enter</button>

        <div id="loader" class="loader hidden" aria-live="polite">
          <div class="spinner" aria-hidden="true"></div>
          <div id="loaderText" class="loader-text"></div>
          <div id="loaderGraphic" class="loader-graphic" aria-hidden="true"><span></span></div>
        </div>
      </div>

    </main>

    <main id="vbNode" class="hidden">
      <button id="stopPlayback" class="stop-playback hidden" type="button">Stop</button>
      <div class="vb-subheader">
        <span>Next Up: Intro to Kingdom</span>
        <div>Tap here to start.</div>
      </div>
      <div id="completedPanel" class="completed-panel" role="dialog" aria-live="polite">
        <h2>Artifacts for "Princess V"</h2>
        <div class="panel-divider" aria-hidden="true"></div>
        <ul id="completedList"></ul>
      </div>
      <div id="countdownPanel" class="countdown-panel">
        <div>Time remaining before this node is scheduled to be deleted:</div>
        <div id="countdownTime" class="countdown-time">--</div>
      </div>
      <div id="logoPanel" class="logo-panel">
        <img src="Logo.png" alt="Logo">
        <button id="leaveButton" class="leave-button" type="button">Leave this node</button>
      </div>
      <div id="rosesPanel" class="roses-panel hidden" role="dialog" aria-live="polite">
        <div class="roses-header">
          <button id="rosesBackTop" class="roses-back-top" type="button">×</button>
          <div id="rosesTitle" class="roses-title"></div>
        </div>
        <div class="roses-body">
          <div class="roses-polaroid">
            <img id="rosesImage" class="roses-image" src="NineRoseComics/1.png" alt="Image 1">
          </div>
          <div id="rosesNote" class="roses-note">Image 1 — (poem/notes here)</div>
        </div>
        <div class="roses-nav">
          <button id="rosesPrev" class="roses-prev" type="button">‹</button>
          <div id="rosesCounter" class="roses-counter">1/12</div>
          <button id="rosesNext" class="roses-next" type="button">›</button>
        </div>
      </div>
      <div id="snapshotCard" class="thought" role="button" tabindex="0" aria-live="polite">
        <div id="snapshotText"></div>
      </div>
    </main>

    <script>
      const deviceText = document.getElementById("deviceText");
      const statusText = document.getElementById("statusText");
      const usernameInput = document.getElementById("username");
      const passwordInput = document.getElementById("password");
      const enterButton = document.getElementById("enterButton");
      const actionArea = document.getElementById("actionArea");
      const loader = document.getElementById("loader");
      const loaderText = document.getElementById("loaderText");
      const loaderGraphic = document.getElementById("loaderGraphic");
      const kingdomNode = document.getElementById("kingdomNode");
      const vbNode = document.getElementById("vbNode");
      const completedPanel = document.getElementById("completedPanel");
      const completedList = document.getElementById("completedList");
      const stopPlayback = document.getElementById("stopPlayback");
      const snapshotCard = document.getElementById("snapshotCard");
      const snapshotText = document.getElementById("snapshotText");
      const vbSubheader = document.querySelector(".vb-subheader");
      const rosesPanel = document.getElementById("rosesPanel");
      const rosesNext = document.getElementById("rosesNext");
      const rosesPrev = document.getElementById("rosesPrev");
      const rosesBackTop = document.getElementById("rosesBackTop");
      const rosesCounter = document.getElementById("rosesCounter");
      const rosesImage = document.getElementById("rosesImage");
      const rosesNote = document.getElementById("rosesNote");
      const rosesTitle = document.getElementById("rosesTitle");
      const countdownPanel = document.getElementById("countdownPanel");
      const countdownTime = document.getElementById("countdownTime");
      const leaveButton = document.getElementById("leaveButton");

      const finaleNotes = {
        1: "1/48 well because I’m the smartest person in the world, it’s only natural for me to wake up with super complex thoughts every morning. I already figured out special relativity and tbh even Einsteins hardest formulas were soooo not impressive.”",
        2: "2/48 but just like the great inventors in human history, I too had a wonderful idea. Not gonna lie it will probably be one of the best inventions of all time, and fortunately I knew exactly who I could share it with”",
        3: "3/48 within the next 10 minutes I was already at Target (not doing groceries). In the chance I did see you in the afternoon, I wanted it to already be made.",
        4: "4/48 of course the flowers were the first thing I saw when I walked in, normally I go straight for roses but I realized there are flowers other than roses (in other words I thought maybeee you’d like sunflowers)",
        5: "5/48 but I will say the roses looked super duper fresh and they had like a pinkish hue to them so I thought ‘hmm maybe I should just stick to roses’",
        6: "6/48 I ended up spending a considerable amount of time looking at the flowers trying to think about which ones you’d like more. I also definitely didn’t wanna get you something you’d hate.",
        7: "7/48 After spending that much time, I went on a side quest to go get the vase (also I didn’t want anyone to see me getting flowers bc it’s totally unlike me). I was looking for this pinkish vase but couldn’t find it so I decided to get this black vase. (I also found the pink box you saw during this side quest, that was totally spontaneous it just looked cool).",
        8: "8/48 But then I figured it out!",
        9: "9/48 Instead of tryna get that I thought you would like, I thought about what I would feel most confident in giving.",
        10: "10/48 I’ve gone sunflower picking before but giving sunflowers was totally unlike me, so I decided to pick the flower that I liked giving the most (roses of course).",
        11: "11/48 Ta-da! Yea not gonna lie this looked perfect to me to give. But after looking at it for a couple seconds…",
        12: "12/48 “I did some more research and it turns out the wrapper is only there so that flowers can be transported. I never knew you were supposed to take the wrapping off”",
        13: "13/48 I’m glad I did because they looked much more beautiful, so much so that I thought I should go back and get more. (Btw: I got the idea after looking at the vase in the back of this photo, so it wasn’t totally random)",
        14: "14/48 as time passed",
        15: "15/48 they got even prettier",
        16: "16/48 but I didn’t see you at the gym both Saturday and Sunday. I was worried (first time for everything I guess) that they would start wilting since they bloomed so fast",
        17: "17/48 so I decided to text you",
        18: "18/48 I definitely was bawling my eyes out…",
        19: "19/48 Just kidding hahaha (besides the crown this photo does not do me justice at all)",
        20: "20/48 “As each day passed, the flowers got prettier and prettier...”",
        21: "21/48 “But I was unsure if I would be able to give them to you before they wilted, and also I wasn’t even sure if you wanted to receive them at all.”",
        22: "22/48 I could bring them and try to give them to you but you’d probably freak out and start crying or something. Or I could have gone to the gym and it woulda been some random weird person that wasn’t you at the front desk”",
        23: "23/48 Next to the flowers, I saw an incomplete invention. Yes that is a box with a potato inside of it.",
        24: "24/48 The smiling potato gave me an even better idea. No way I was gonna give you a give that initially made you uncomfortable so I had to create a new gift.",
        25: "25/48 On the quest for pink I went",
        26: "26/48 After cutting up one rose, I was sure this would work",
        27: "27/48 Though it took a bit longer than I thought",
        28: "28/48 To be honest I wasn’t expecting that we’d end up talking for an hour after I gave it to you, so lowkey a lot of the things in the gift were already covered. (Btw when I gave you $10 for your bday it was bc it was a more important day, and I didn’t have five bucks, but the $1 here is not a downgrade at all - that’s for you to figure out). Also I hid the pink box underneath the roses bc I think you would have panicked seeing them if I was there but I’m sure it would have been cool once you opened them at home. The box worked out bc in case you had ppl around you I didn’t wanna give you smt that your coworkers would see making you uncomfortable",
        29: "29/48 So to the gym I went",
        30: "30/48 Luckily you were the first person I saw",
        31: "31/48 but of course the side characters were there to spectate",
        32: "32/48 main character energy",
        33: "33/48 once the side characters were out of there I took the 2 mins to quickly explain",
        34: "34/48 it was a deal",
        35: "35/48 So I looked at the roundabout from my window",
        36: "36/48 insert all of our texts and the voice memos I sent here",
        37: "37/48 but I heard a ding",
        38: "38/48 self explanatory",
        39: "39/48 after some time looking at the geese",
        40: "40/48 you made it",
        41: "41/48 and of course I yapped away w the 5 mins I had hahaha",
        42: "42/48 And I was ecstatic later that night because although you didn’t show excitement in the moment",
        43: "43/48 I knew you were probably had a blast (bc who doesn’t like flowers)",
        44: "44/48 Perhaps it was just all one big dream but I’m glad I got to give you the flowers and the gift",
        45: "45/48 Then the next day I had to clean up (peep all my attempts with each post it note)",
        46: "46/48 In fact, with all my attempts I almost ran out of pink post its.",
        47: "47/48 Honestly, I’m glad I gave them to you in time because ngl they wilt insanely fast when not on the stem",
        48: "48/48 The End!"
      };

      function buildFinaleItems() {
        const items = [];
        const basePath = "NineRosesFinale";
        for (let i = 1; i <= 48; i += 1) {
          items.push({
            base: `${basePath}/_${i}`,
            label: `Image ${i}`,
            note: finaleNotes[i] || `Image ${i} — (poem/notes here)`
          });
        }
        return items;
      }

      const episodes = [
        {
          id: "intro",
          title: "Intro to Kingdom",
thoughts: [
  "Welcome, VCB.",
  "This is a small, private node within Lord Ishan’s Kingdom.",
  "It is intentionally separated from the Kingdom’s core systems to avoid interacting with other nodes in the Kingdom.",
  "Lord Ishan has helped us in building this node to protect your experience, keep it simple, truthful, and private.",
  "You benefit from the full security of the Kingdom and can extract from it meaningfully, and can proceed completely at your own pace.",
    "This node was granted a high level of Kingdom processing power.",
  "Because of this, these insights are very close to Lord Ishan’s own thoughts and are shared very carefully and intentionally.",
  "This node represents a small fraction of the tools available at higher nodes of the Kingdom.",
  "but even if you combined all the nodes of the Kingdom, it is merely a farcry from his level of intelligence and wisdom.",
  "If you continue to use this node, additional thoughts and controls could appear over time.",
  "But you will definitely have the option to self destruct this node at any time.",
  "That option will appear after the gift explanation of the story of the 9 Roses.",
  "\"oh yea if you see these bubbles with double quotes then it’s my direct words\"",
  "\"you're kinda smart for getting this far but I knew you would (I'll actually never know for sure though I just trust it hahaha)\"",
  "\"don't overthink it (this is literally less than .0000001% of what I can think about in 1s), just be a girl and enjoy\"",
  "\"and of course I got something like this, I am after all the smartest person in the entire world (keep this on the dl btw if tech companies found out about this they'd never leave me alone)\"",
]


        },
        // 9 Roses (Part 1) is hidden for now.
        {
          id: "roses23",
          title: "9 roses (finale)",
          status: "available",
          mode: "staticGallery",
          galleryItems: buildFinaleItems()
        }
      ];

      const visitorSequence = [
        {
          lines: [
            { html: "Credentials validated!" },
            { html: "User found initiating access protocol" },
            {
              html: "Granting access to user: <span class=\"accent\" id=\"nameSpan\"></span>",
              typeName: "Victoria Butterfield",
              typeDelay: 500
            }
          ]
        },
        {
          lines: [
            { html: "Checking special instructions granted by \ud83d\udc51..." }
          ]
        },
        {
          lines: [
            { html: "3 instructions found:" },
            { html: "&nbsp;&nbsp;1) cmd: grant node 99.9% of Kingdom processing power" },
            { html: "&nbsp;&nbsp;2) cmd: mask architectural complexity" },
            { html: "&nbsp;&nbsp;3) cmd: enable user-safe abstraction" }
          ]
        },
        {
          lines: [
            { html: "cmd: direct retrieval from Kingdom vault [8055:2:34:11:11]" },
            { html: "cmd: direct retrieval from Kingdom vault [8055:2:34:11:1888] cmd: explain gift" },
            { html: "Artifact located: Intro to Kingdom" },
            { html: "Artifact located: 9 roses \ud83c\udf39" },
            { html: "cmd: Finalizing access..." }
          ]
        },
        {
          lines: [
            { html: "Welcome VCB!" }
          ],
          showGraphic: true
        }
      ];

      const creatorSequence = [
        {
          lines: [
            { html: "Lord Ishan" }
          ]
        }
      ];

      let snapshotIndex = 0;
      const vbStateKey = "vbNodeState";
      const episodeStateKey = "vbEpisodeState";
      const finaleStateKey = "vbFinaleState";
      let thoughtAnimId = null;
      let thoughtState = null;
      let rosesIndex = 0;
      let isPlaying = false;

      function defaultEpisodeState() {
        const episodeMap = {};
        for (const episode of episodes) {
          episodeMap[episode.id] = { index: 0, completedAt: null, started: false };
        }
        return {
          activeId: episodes[0].id,
          episodes: episodeMap
        };
      }

      function loadEpisodeState() {
        try {
          const parsed = JSON.parse(localStorage.getItem(episodeStateKey));
          if (!parsed) {
            return defaultEpisodeState();
          }
          if (parsed.activeId && parsed.episodes) {
            return parsed;
          }
          if (parsed.episodeId) {
            const nextState = defaultEpisodeState();
            nextState.activeId = parsed.episodeId;
            if (!nextState.episodes[parsed.episodeId]) {
              nextState.episodes[parsed.episodeId] = { index: 0, completedAt: null, started: false };
            }
            nextState.episodes[parsed.episodeId] = {
              ...nextState.episodes[parsed.episodeId],
              index: parsed.index || 0,
              completedAt: parsed.completedAt || null,
              started: parsed.started || false
            };
            return nextState;
          }
          return defaultEpisodeState();
        } catch {
          return defaultEpisodeState();
        }
      }

      function getActiveEpisode(state) {
        return episodes.find((episode) => episode.id === state.activeId) || episodes[0];
      }

      function getEpisodeState(state, id) {
        return state.episodes[id] || { index: 0, completedAt: null, started: false };
      }

      function saveEpisodeProgress(state, id, progress) {
        const nextState = {
          activeId: state.activeId,
          episodes: {
            ...state.episodes,
            [id]: progress
          }
        };
        saveEpisodeState(nextState);
        return nextState;
      }

      function getEpisodeItems(episode) {
        if (episode.mode === "staticGallery") {
          return [];
        }
        const items = [];
        for (const thought of episode.thoughts) {
          items.push({ type: "text", value: thought });
        }
        if (episode.imagesCount) {
          const basePath = episode.imagesPath ? `${episode.imagesPath}/` : "";
          for (let i = 1; i <= episode.imagesCount; i += 1) {
            items.push({ type: "image", value: `${basePath}${i}.png` });
          }
        }
        if (episode.closing) {
          items.push({ type: "text", value: episode.closing });
        }
        return items;
      }

      function preloadEpisodeImages() {
        for (const episode of episodes) {
          if (!episode.imagesCount) {
            continue;
          }
          const basePath = episode.imagesPath ? `${episode.imagesPath}/` : "";
          for (let i = 1; i <= episode.imagesCount; i += 1) {
            const img = new Image();
            img.src = `${basePath}${i}.png`;
          }
        }
      }

      let finalePreloaded = false;
      function preloadFinaleImages() {
        if (finalePreloaded) {
          return;
        }
        finalePreloaded = true;
        const items = buildFinaleItems();
        for (const item of items) {
          const png = new Image();
          png.src = `${item.base}.png`;
          const jpeg = new Image();
          jpeg.src = `${item.base}.jpeg`;
        }
      }

      function saveEpisodeState(state) {
        localStorage.setItem(episodeStateKey, JSON.stringify(state));
      }

      function renderEpisodes() {
        completedList.innerHTML = "";
        const state = loadEpisodeState();
        for (const episode of episodes) {
          const li = document.createElement("li");
          li.textContent = `${episodes.indexOf(episode) + 1}. ${episode.title}`;
          const actions = document.createElement("div");
          actions.className = "episode-actions";
          const play = document.createElement("button");
          play.type = "button";
          play.textContent = "Play";
          play.disabled = isPlaying;
          play.addEventListener("click", () => {
            startEpisodeFor(episode.id);
          });
          actions.appendChild(play);
          li.appendChild(actions);
          completedList.appendChild(li);
        }
      }

      function positionTopPanels() {
        requestAnimationFrame(() => {
          const artifactsRect = completedPanel.getBoundingClientRect();
          const countdownTop = Math.round(artifactsRect.bottom + 12);
          countdownPanel.style.top = `${countdownTop}px`;
        });
      }

      function updateCountdown() {
        const target = new Date("2026-02-15T00:00:00");
        const now = new Date();
        let diff = target - now;
        if (diff <= 0) {
          countdownTime.textContent = "0d 0h 0m 0s";
          return;
        }
        const totalSeconds = Math.floor(diff / 1000);
        const days = Math.floor(totalSeconds / 86400);
        const hours = Math.floor((totalSeconds % 86400) / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        countdownTime.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
      }

      function getDeviceType() {
        const ua = navigator.userAgent;
        if (/iPhone/i.test(ua)) {
          return "iPhone";
        }
        if (/iPad/i.test(ua)) {
          return "iPad";
        }
        if (/Android/i.test(ua)) {
          return "Android";
        }
        if (/Macintosh|Windows|Linux/i.test(ua)) {
          return "Desktop";
        }
        return "Unknown";
      }

      function isIphone() {
        return /iPhone/i.test(navigator.userAgent);
      }

      function updateEnterVisibility() {
        const hasUser = usernameInput.value.trim().length > 0;
        const hasPass = passwordInput.value.trim().length > 0;
        enterButton.classList.toggle("is-active", hasUser && hasPass);
      }

      function setSnapshot(index) {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const items = getEpisodeItems(activeEpisode);
        snapshotIndex = Math.min(index, items.length - 1);
        const item = items[snapshotIndex];
        snapshotText.innerHTML = "";
        if (item.type === "image") {
          const img = document.createElement("img");
          img.src = item.value;
          img.alt = "";
          img.loading = "eager";
          snapshotText.appendChild(img);
        } else {
          snapshotText.textContent = item.value;
        }
        positionThought();
        const progress = getEpisodeState(state, activeEpisode.id);
        const updatedProgress = {
          index: snapshotIndex,
          completedAt: progress.completedAt,
          started: true
        };
        const nextState = saveEpisodeProgress(state, activeEpisode.id, updatedProgress);
        localStorage.setItem(vbStateKey, JSON.stringify({ node: "vb", activeId: state.activeId }));
        updateSubheader(nextState);
      }

      function resetLogin() {
        statusText.textContent = "";
        statusText.classList.remove("error");
        usernameInput.disabled = false;
        passwordInput.disabled = false;
        usernameInput.value = "";
        passwordInput.value = "";
        updateEnterVisibility();
        loader.classList.add("hidden");
        loaderText.textContent = "";
        loaderGraphic.style.display = "none";
        enterButton.disabled = false;
        actionArea.classList.remove("loading");
      }

      function showKingdom() {
        document.body.classList.remove("vb");
        document.body.classList.add("kingdom");
        kingdomNode.classList.remove("hidden");
        vbNode.classList.add("hidden");
        rosesPanel.classList.add("hidden");
        resetLogin();
        localStorage.removeItem(vbStateKey);
        stopThoughtMotion();
      }

      function showVBNode(isCreator) {
        document.body.classList.remove("kingdom");
        document.body.classList.add("vb");
        kingdomNode.classList.add("hidden");
        vbNode.classList.remove("hidden");
        rosesPanel.classList.add("hidden");
        renderEpisodes();
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const progress = getEpisodeState(state, activeEpisode.id);
        localStorage.setItem(vbStateKey, JSON.stringify({ node: "vb", activeId: state.activeId }));
        snapshotIndex = typeof progress.index === "number" ? progress.index : 0;
        if (activeEpisode.mode === "staticGallery") {
          snapshotCard.classList.add("hidden");
          stopThoughtMotion();
          const finaleState = localStorage.getItem(finaleStateKey);
          if (finaleState) {
            try {
              const parsed = JSON.parse(finaleState);
              if (typeof parsed.index === "number") {
                openRosesPanel(activeEpisode, parsed.index);
              }
            } catch {
              localStorage.removeItem(finaleStateKey);
            }
          }
        } else if (progress.completedAt) {
          snapshotCard.classList.add("hidden");
          stopThoughtMotion();
        } else if (progress.started) {
          snapshotCard.classList.remove("hidden");
          setSnapshot(snapshotIndex);
          startThoughtMotion();
        } else {
          snapshotCard.classList.add("hidden");
        }
        updateSubheader(state);
        history.pushState({ node: "vb" }, "", "#vb");
        positionTopPanels();
      }

      function typeName(text, delayMs = 0) {
        const target = document.getElementById("nameSpan");
        if (!target) {
          return Promise.resolve();
        }
        let index = 0;
        return new Promise((resolve) => {
          setTimeout(() => {
          const intervalId = setInterval(() => {
            target.textContent += text[index];
            index += 1;
            if (index >= text.length) {
              clearInterval(intervalId);
              resolve();
            }
          }, 70);
          }, delayMs);
        });
      }

      function playSequence(groups, intervalMs, onDone) {
        let groupIndex = 0;

        const runGroup = async () => {
          const group = groups[groupIndex];
          loaderText.innerHTML = "";
          loaderGraphic.style.display = group.showGraphic ? "block" : "none";
          for (const line of group.lines) {
            const lineEl = document.createElement("div");
            lineEl.className = "line fade-in";
            lineEl.innerHTML = line.html;
            loaderText.appendChild(lineEl);
            if (line.typeName) {
              await typeName(line.typeName, line.typeDelay || 0);
            }
            await new Promise((resolve) => setTimeout(resolve, intervalMs));
          }

          groupIndex += 1;
          if (groupIndex >= groups.length) {
            onDone();
            return;
          }
          setTimeout(runGroup, intervalMs);
        };

        runGroup();
      }

      function handleLogin() {
        const username = usernameInput.value.trim().toLowerCase();
        const password = passwordInput.value.trim().toLowerCase();

        statusText.textContent = "";
        statusText.classList.remove("error");

        const visitorMatch = username === "kingdomofli-node8850" && password === "vcb";
        const creatorMatch = username === "kingdomofli-node8850" && password === "vcbima";

        if (!visitorMatch && !creatorMatch) {
          statusText.textContent = "Access Denied";
          statusText.classList.add("error");
          return;
        }

        if (!isIphone()) {
          statusText.textContent = "Access Denied: This node can only be accessed on an iPhone browser.";
          statusText.classList.add("error");
          return;
        }

        usernameInput.disabled = true;
        passwordInput.disabled = true;
        enterButton.disabled = true;
        enterButton.classList.remove("is-active");
        actionArea.classList.add("loading");
        const sequence = creatorMatch ? creatorSequence : visitorSequence;
        const intervalMs = creatorMatch ? 1100 : 2000;
        loader.classList.remove("hidden");
        playSequence(sequence, intervalMs, () => {
          snapshotIndex = 0;
          saveEpisodeState(defaultEpisodeState());
          showVBNode(creatorMatch);
        });
      }

      deviceText.textContent = `Device: ${getDeviceType()}`;
      if (!history.state) {
        history.replaceState({ node: "kingdom" }, "", window.location.pathname + window.location.search);
      }
      let restored = false;
      const savedState = localStorage.getItem(vbStateKey);
      if (savedState) {
        try {
          const parsed = JSON.parse(savedState);
          if (parsed && parsed.node === "vb") {
            showVBNode(false);
            restored = true;
          }
        } catch {
          localStorage.removeItem(vbStateKey);
        }
      }
      updateEnterVisibility();
      if (!restored) {
        snapshotCard.classList.add("hidden");
      }
      preloadEpisodeImages();
      updateCountdown();
      setInterval(updateCountdown, 1000);

      leaveButton.addEventListener("click", () => {
        history.pushState({ node: "kingdom" }, "", window.location.pathname + window.location.search);
        showKingdom();
      });

      usernameInput.addEventListener("input", updateEnterVisibility);
      passwordInput.addEventListener("input", updateEnterVisibility);
      enterButton.addEventListener("click", handleLogin);
      passwordInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          handleLogin();
        }
      });

      function advanceSnapshot() {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const items = getEpisodeItems(activeEpisode);
        const progress = getEpisodeState(state, activeEpisode.id);
        const lastIndex = items.length - 1;
        if (progress.completedAt) {
          snapshotCard.classList.add("hidden");
          updateSubheader(state);
          return;
        }
        if (snapshotIndex >= lastIndex) {
          endEpisode();
          return;
        }
        snapshotCard.classList.remove("fade-in");
        void snapshotCard.offsetWidth;
        snapshotIndex = Math.min(snapshotIndex + 1, lastIndex);
        const item = items[snapshotIndex];
        snapshotText.innerHTML = "";
        if (item.type === "image") {
          const img = document.createElement("img");
          img.src = item.value;
          img.alt = "";
          img.loading = "eager";
          snapshotText.appendChild(img);
        } else {
          snapshotText.textContent = item.value;
        }
        positionThought();
        const updatedProgress = {
          index: snapshotIndex,
          completedAt: null,
          started: true
        };
        const nextState = saveEpisodeProgress(state, activeEpisode.id, updatedProgress);
        localStorage.setItem(vbStateKey, JSON.stringify({ node: "vb", activeId: state.activeId }));
        snapshotCard.classList.add("fade-in");
        updateSubheader(nextState);
      }

      function positionThought() {
        const padding = 24;
        const headerBottom = vbSubheader.getBoundingClientRect().bottom + 12;
        const maxX = Math.max(padding, window.innerWidth - snapshotCard.offsetWidth - padding);
        const maxY = Math.max(headerBottom, window.innerHeight - snapshotCard.offsetHeight - padding);
        const x = padding + Math.random() * (maxX - padding);
        const y = headerBottom + Math.random() * (maxY - headerBottom);
        snapshotCard.style.left = `${Math.round(x)}px`;
        snapshotCard.style.top = `${Math.round(y)}px`;
        const speed = 40 + Math.random() * 25;
        const angle = Math.random() * Math.PI * 2;
        thoughtState = {
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed
        };
      }

      function updateSubheader(state) {
        const left = vbSubheader.querySelector("span");
        const right = vbSubheader.querySelector("div");
        const activeEpisode = getActiveEpisode(state);
        const progress = getEpisodeState(state, activeEpisode.id);
        if (activeEpisode.mode === "staticGallery") {
          left.textContent = "All Artifacts Have Been Released!";
          right.textContent = "";
          return;
        }
        const items = getEpisodeItems(activeEpisode);
        const lastIndex = items.length - 1;
        if (progress.started && !progress.completedAt) {
          left.textContent = "";
          right.textContent = "";
          return;
        }
        left.textContent = "All artifacts unlocked";
        right.textContent = "Tap Artifacts to play.";
      }

      function startPlayback(showStop = true) {
        isPlaying = true;
        document.body.classList.add("playing");
        completedPanel.classList.add("hidden");
        stopPlayback.classList.toggle("hidden", !showStop);
        renderEpisodes();
      }

      function stopPlaybackNow() {
        isPlaying = false;
        document.body.classList.remove("playing");
        completedPanel.classList.remove("hidden");
        stopPlayback.classList.add("hidden");
        renderEpisodes();
        positionTopPanels();
      }

      function setRosesPanelItem(episode) {
        const items = episode.galleryItems || [];
        if (!items.length) {
          return;
        }
        const item = items[rosesIndex];
        rosesTitle.textContent = "";
        rosesImage.onerror = null;
        rosesImage.dataset.ext = "png";
        rosesImage.onerror = () => {
          if (rosesImage.dataset.ext === "png") {
            rosesImage.dataset.ext = "jpeg";
            rosesImage.src = `${item.base}.jpeg`;
          }
        };
        rosesImage.src = `${item.base}.png`;
        rosesImage.alt = item.label;
        rosesNote.textContent = item.note;
        rosesCounter.textContent = `${rosesIndex + 1}/${items.length}`;
        rosesPrev.disabled = rosesIndex === 0;
        rosesNext.disabled = rosesIndex >= items.length - 1;
        localStorage.setItem(finaleStateKey, JSON.stringify({ index: rosesIndex }));
      }

      function openRosesPanel(episode, startIndex = 0) {
        const maxIndex = (episode.galleryItems || []).length - 1;
        rosesIndex = Math.max(0, Math.min(startIndex, maxIndex));
        document.body.classList.add("playing");
        rosesPanel.classList.remove("hidden");
        snapshotCard.classList.add("hidden");
        stopThoughtMotion();
        startPlayback(false);
        preloadFinaleImages();
        setRosesPanelItem(episode);
      }

      function closeRosesPanel() {
        rosesPanel.classList.add("hidden");
        document.body.classList.remove("playing");
        localStorage.removeItem(finaleStateKey);
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const progress = getEpisodeState(state, activeEpisode.id);
        if (activeEpisode.mode !== "staticGallery" && progress.started && !progress.completedAt) {
          snapshotCard.classList.remove("hidden");
          setSnapshot(snapshotIndex);
          startThoughtMotion();
        }
        stopPlaybackNow();
        positionTopPanels();
      }

      function endEpisode() {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const items = getEpisodeItems(activeEpisode);
        const progress = getEpisodeState(state, activeEpisode.id);
        if (progress.completedAt) {
          return;
        }
        if (snapshotIndex < items.length - 1) {
          return;
        }
        const updatedProgress = { index: snapshotIndex, completedAt: true, started: true };
        const nextState = saveEpisodeProgress(state, activeEpisode.id, updatedProgress);
        snapshotCard.classList.add("hidden");
        stopThoughtMotion();
        updateSubheader(nextState);
      }

      function startEpisode() {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const progress = getEpisodeState(state, activeEpisode.id);
        if (progress.completedAt) {
          return;
        }
        if (activeEpisode.mode === "staticGallery") {
          const fresh = { index: 0, completedAt: null, started: true };
          saveEpisodeProgress(state, activeEpisode.id, fresh);
          openRosesPanel(activeEpisode);
          updateSubheader(loadEpisodeState());
          return;
        }
        const fresh = { index: 0, completedAt: null, started: true };
        snapshotIndex = 0;
        snapshotCard.classList.remove("hidden");
        const nextState = saveEpisodeProgress(state, activeEpisode.id, fresh);
        setSnapshot(0);
        startThoughtMotion();
        updateSubheader(nextState);
      }

      function startEpisodeFor(id) {
        const state = loadEpisodeState();
        const nextState = {
          activeId: id,
          episodes: state.episodes
        };
        const activeEpisode = episodes.find((episode) => episode.id === id);
        const fresh = { index: 0, completedAt: null, started: true };
        snapshotIndex = 0;
        const updatedState = saveEpisodeProgress(nextState, id, fresh);
        if (activeEpisode && activeEpisode.mode === "staticGallery") {
          openRosesPanel(activeEpisode);
          updateSubheader(updatedState);
          return;
        }
        startPlayback();
        snapshotCard.classList.remove("hidden");
        setSnapshot(0);
        startThoughtMotion();
        updateSubheader(updatedState);
      }

      function getThoughtBounds() {
        const padding = 24;
        const headerBottom = vbSubheader.getBoundingClientRect().bottom + 12;
        return {
          minX: padding,
          maxX: Math.max(padding, window.innerWidth - snapshotCard.offsetWidth - padding),
          minY: headerBottom,
          maxY: Math.max(headerBottom, window.innerHeight - snapshotCard.offsetHeight - padding)
        };
      }

      function startThoughtMotion() {
        if (thoughtAnimId || snapshotCard.classList.contains("hidden")) {
          return;
        }
        let lastTime = performance.now();
        const step = (now) => {
          if (!thoughtState || snapshotCard.classList.contains("hidden")) {
            thoughtAnimId = null;
            return;
          }
          const dt = (now - lastTime) / 1000;
          lastTime = now;
          const bounds = getThoughtBounds();
          thoughtState.x += thoughtState.vx * dt;
          thoughtState.y += thoughtState.vy * dt;
          if (thoughtState.x <= bounds.minX || thoughtState.x >= bounds.maxX) {
            thoughtState.vx *= -1;
            thoughtState.x = Math.min(Math.max(thoughtState.x, bounds.minX), bounds.maxX);
          }
          if (thoughtState.y <= bounds.minY || thoughtState.y >= bounds.maxY) {
            thoughtState.vy *= -1;
            thoughtState.y = Math.min(Math.max(thoughtState.y, bounds.minY), bounds.maxY);
          }
          snapshotCard.style.left = `${Math.round(thoughtState.x)}px`;
          snapshotCard.style.top = `${Math.round(thoughtState.y)}px`;
          thoughtAnimId = requestAnimationFrame(step);
        };
        thoughtAnimId = requestAnimationFrame(step);
      }

      function stopThoughtMotion() {
        if (thoughtAnimId) {
          cancelAnimationFrame(thoughtAnimId);
          thoughtAnimId = null;
        }
      }

      snapshotCard.addEventListener("click", advanceSnapshot);
      snapshotCard.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          advanceSnapshot();
        }
      });

      rosesPrev.addEventListener("click", () => {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        if (!activeEpisode || activeEpisode.mode !== "staticGallery") {
          return;
        }
        if (rosesIndex <= 0) {
          return;
        }
        rosesIndex -= 1;
        setRosesPanelItem(activeEpisode);
      });

      rosesBackTop.addEventListener("click", () => {
        closeRosesPanel();
      });

      stopPlayback.addEventListener("click", () => {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        const progress = getEpisodeState(state, activeEpisode.id);
        if (activeEpisode.mode === "staticGallery") {
          rosesPanel.classList.add("hidden");
        } else {
          snapshotCard.classList.add("hidden");
          stopThoughtMotion();
        }
        const updatedProgress = {
          index: progress.index || snapshotIndex,
          completedAt: progress.completedAt || null,
          started: false
        };
        const nextState = saveEpisodeProgress(state, activeEpisode.id, updatedProgress);
        updateSubheader(nextState);
        stopPlaybackNow();
      });

      rosesNext.addEventListener("click", () => {
        const state = loadEpisodeState();
        const activeEpisode = getActiveEpisode(state);
        if (!activeEpisode || activeEpisode.mode !== "staticGallery") {
          return;
        }
        const items = activeEpisode.galleryItems || [];
        if (!items.length) {
          return;
        }
        if (rosesIndex >= items.length - 1) {
          return;
        }
        rosesIndex += 1;
        setRosesPanelItem(activeEpisode);
        if (rosesIndex >= items.length - 1) {
          const updatedProgress = {
            index: 0,
            completedAt: new Date().toISOString(),
            started: true
          };
          const nextState = saveEpisodeProgress(state, activeEpisode.id, updatedProgress);
          updateSubheader(nextState);
        }
      });


      window.addEventListener("popstate", (event) => {
        if (event.state && event.state.node === "kingdom") {
          showKingdom();
        }
      });

      document.addEventListener("contextmenu", (event) => event.preventDefault());
    </script>
  </body>
</html>
